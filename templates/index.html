{% extends "base.html" %} {% block title %}Dashboard - PriceGuard{% endblock %}
{% block content %}
<div class="container-fluid">
  <div class="row">
    <!-- Main Content -->
    <div class="col-12">
      <div class="p-4">
        <!-- Header -->
        <div class="d-flex justify-content-between align-items-center mb-4">
          <div>
            <h1 class="h3 mb-0">Crypto Dashboard</h1>
            <p class="text-muted mb-0">Track your favorite cryptocurrencies</p>
          </div>
          <button
            class="btn btn-primary"
            data-bs-toggle="modal"
            data-bs-target="#addCryptoModal"
          >
            <i class="bi bi-plus-circle"></i> Add Crypto
          </button>
        </div>

        <!-- Watchlist -->
        <div class="row mb-4">
          <div class="col-12">
            <div class="card">
              <div class="card-header bg-white">
                <h5 class="mb-0">
                  <i class="bi bi-star-fill text-warning"></i> My Watchlist
                </h5>
              </div>
              <div class="card-body">
                <div id="watchlistLoading" class="text-center py-5">
                  <div class="loading mx-auto"></div>
                  <p class="mt-3 text-muted">Loading watchlist...</p>
                </div>

                <div id="watchlistEmpty" class="text-center py-5 d-none">
                  <i class="bi bi-inbox text-muted" style="font-size: 3rem"></i>
                  <p class="mt-3 text-muted">
                    Your watchlist is empty. Add some cryptocurrencies to get
                    started!
                  </p>
                </div>

                <div id="watchlistContent" class="table-responsive d-none">
                  <table class="table table-hover align-middle">
                    <thead>
                      <tr>
                        <th>Asset</th>
                        <th>Price</th>
                        <th>24h Change</th>
                        <th>Market Cap</th>
                        <th>Alert Threshold</th>
                        <th>Actions</th>
                      </tr>
                    </thead>
                    <tbody id="watchlistTableBody"></tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Popular Cryptocurrencies -->
        <div class="row mb-4">
          <div class="col-12">
            <div class="card">
              <div class="card-header bg-white">
                <h5 class="mb-0">
                  <i class="bi bi-fire"></i> Popular Cryptocurrencies
                </h5>
              </div>
              <div class="card-body">
                <div id="popularCryptosLoading" class="text-center py-3">
                  <div class="loading mx-auto"></div>
                  <p class="mt-2 text-muted">Loading popular cryptos...</p>
                </div>
                <div id="popularCryptosContent" class="d-none">
                  <div class="table-responsive">
                    <table class="table table-hover align-middle mb-0">
                      <thead>
                        <tr>
                          <th>Asset</th>
                          <th>Price</th>
                          <th>24h Change</th>
                          <th>Market Cap</th>
                          <th>Volume (24h)</th>
                          <th></th>
                        </tr>
                      </thead>
                      <tbody id="popularCryptosTableBody"></tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Price History -->
        <div class="row mb-4">
          <div class="col-12">
            <div class="card">
              <div
                class="card-header bg-white d-flex justify-content-between align-items-center"
              >
                <h5 class="mb-0">
                  <i class="bi bi-graph-up"></i> Price History
                </h5>
                <select class="form-select w-auto" id="cryptoSelector">
                  <option value="">Select a crypto...</option>
                </select>
              </div>
              <div class="card-body">
                <div id="chartLoading" class="text-center py-5 d-none">
                  <div class="loading mx-auto"></div>
                  <p class="mt-3 text-muted">Loading chart...</p>
                </div>

                <div id="chartEmpty" class="text-center py-5">
                  <i
                    class="bi bi-graph-up text-muted"
                    style="font-size: 3rem"
                  ></i>
                  <p class="mt-3 text-muted">
                    Select a cryptocurrency to view price history
                  </p>
                </div>

                <div id="chartContent" class="d-none">
                  <!-- Time period buttons -->
                  <div
                    class="btn-group mb-3"
                    role="group"
                    id="timePeriodButtons"
                  >
                    <button
                      type="button"
                      class="btn btn-outline-primary btn-sm active"
                      data-days="1"
                    >
                      24h
                    </button>
                    <button
                      type="button"
                      class="btn btn-outline-primary btn-sm"
                      data-days="7"
                    >
                      7d
                    </button>
                    <button
                      type="button"
                      class="btn btn-outline-primary btn-sm"
                      data-days="30"
                    >
                      30d
                    </button>
                    <button
                      type="button"
                      class="btn btn-outline-primary btn-sm"
                      data-days="365"
                    >
                      1y
                    </button>
                  </div>

                  <!-- Price Statistics -->
                  <div id="priceStats" class="row mb-3 text-center">
                    <div class="col-3">
                      <small class="text-muted">Open</small>
                      <div class="fw-bold" id="statOpen">-</div>
                    </div>
                    <div class="col-3">
                      <small class="text-muted">High</small>
                      <div class="fw-bold text-success" id="statHigh">-</div>
                    </div>
                    <div class="col-3">
                      <small class="text-muted">Low</small>
                      <div class="fw-bold text-danger" id="statLow">-</div>
                    </div>
                    <div class="col-3">
                      <small class="text-muted">Volume</small>
                      <div class="fw-bold" id="statVolume">-</div>
                    </div>
                  </div>

                  <div style="height: 300px; position: relative">
                    <canvas id="priceChart"></canvas>
                  </div>

                  <div class="mt-3 text-center">
                    <a
                      href="#"
                      id="downloadCsvBtn"
                      class="btn btn-outline-primary btn-sm me-2"
                    >
                      <i class="bi bi-download"></i> Download CSV
                    </a>
                    <a
                      href="#"
                      id="downloadWatchlistBtn"
                      class="btn btn-outline-secondary btn-sm"
                    >
                      <i class="bi bi-file-earmark-spreadsheet"></i> Export
                      Watchlist
                    </a>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Price Predictions -->
<div class="container mt-4">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div
          class="card-header bg-white d-flex justify-content-between align-items-center"
        >
          <h5 class="mb-0">
            <i class="bi bi-graph-up-arrow"></i> Price Predictions
          </h5>
          <select class="form-select w-auto" id="predictionCryptoSelector">
            <option value="">Select a crypto...</option>
          </select>
        </div>
        <div class="card-body">
          <div id="predictionLoading" class="text-center py-5 d-none">
            <div class="loading mx-auto"></div>
            <p class="mt-3 text-muted">Generating predictions...</p>
          </div>

          <div id="predictionEmpty" class="text-center py-5">
            <i
              class="bi bi-graph-up-arrow text-muted"
              style="font-size: 3rem"
            ></i>
            <p class="mt-3 text-muted">
              Select a cryptocurrency to view price predictions
            </p>
          </div>

          <div id="predictionContent" class="d-none">
            <!-- Model selector and time period buttons -->
            <div class="row mb-3">
              <div class="col-md-6">
                <small class="text-muted">Prediction Model:</small>
                <select
                  class="form-select form-select-sm"
                  id="predictionModelSelector"
                >
                  <option value="linear">Linear Regression</option>
                  <option value="tree">Decision Tree</option>
                </select>
              </div>
              <div class="col-md-6">
                <small class="text-muted">Predict next:</small>
                <div
                  class="btn-group w-100"
                  role="group"
                  id="predictionTimePeriodButtons"
                >
                  <button
                    type="button"
                    class="btn btn-outline-success btn-sm active"
                    data-days="1"
                    title="Predict next 24 hours"
                  >
                    24h
                  </button>
                  <button
                    type="button"
                    class="btn btn-outline-success btn-sm"
                    data-days="7"
                    title="Predict next 7 days"
                  >
                    7d
                  </button>
                  <button
                    type="button"
                    class="btn btn-outline-success btn-sm"
                    data-days="30"
                    title="Predict next 30 days"
                  >
                    30d
                  </button>
                  <button
                    type="button"
                    class="btn btn-outline-success btn-sm"
                    data-days="365"
                    title="Predict next year"
                  >
                    1y
                  </button>
                </div>
              </div>
            </div>

            <!-- Price Statistics -->
            <div id="predictionPriceStats" class="row mb-3 text-center">
              <div class="col-3">
                <small class="text-muted">Open</small>
                <div class="fw-bold" id="predictionStatOpen">-</div>
              </div>
              <div class="col-3">
                <small class="text-muted">High</small>
                <div class="fw-bold text-success" id="predictionStatHigh">
                  -
                </div>
              </div>
              <div class="col-3">
                <small class="text-muted">Low</small>
                <div class="fw-bold text-danger" id="predictionStatLow">-</div>
              </div>
              <div class="col-3">
                <small class="text-muted">Volume</small>
                <div class="fw-bold" id="predictionStatVolume">-</div>
              </div>
            </div>

            <div style="height: 300px; position: relative">
              <canvas id="predictionChart"></canvas>
            </div>

            <div class="alert alert-info mt-3">
              <i class="bi bi-info-circle"></i>
              <strong>Note:</strong> Predictions are based on historical data
              and machine learning models. They should not be used as the sole
              basis for investment decisions.
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Add Crypto Modal -->
<div class="modal fade" id="addCryptoModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Add Cryptocurrency</h5>
        <button
          type="button"
          class="btn-close"
          data-bs-dismiss="modal"
        ></button>
      </div>
      <div class="modal-body">
        <form id="addCryptoForm">
          <div class="mb-3">
            <label for="cryptoSearch" class="form-label"
              >Search Cryptocurrency</label
            >
            <input
              type="text"
              class="form-control"
              id="cryptoSearch"
              placeholder="Search by name or symbol..."
              autocomplete="off"
            />
            <div
              id="searchResults"
              class="list-group mt-2"
              style="max-height: 300px; overflow-y: auto; display: none"
            ></div>
            <input type="hidden" id="selectedCryptoSymbol" />
            <input type="hidden" id="selectedCryptoId" />
            <input type="hidden" id="selectedCryptoName" />
            <div id="selectedCrypto" class="mt-2" style="display: none">
              <div class="alert alert-info d-flex align-items-center">
                <i class="bi bi-check-circle-fill me-2"></i>
                <span id="selectedCryptoText"></span>
              </div>
            </div>
          </div>

          <div class="mb-3">
            <label for="alertPercent" class="form-label"
              >Alert Threshold (%)</label
            >
            <input
              type="number"
              class="form-control"
              id="alertPercent"
              value="5"
              step="0.1"
              min="0"
              required
            />
            <div class="form-text">
              Get notified when price changes by this percentage
            </div>
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
          Cancel
        </button>
        <button type="button" class="btn btn-primary" id="addCryptoBtn">
          Add to Watchlist
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Edit Alert Modal -->
<div class="modal fade" id="editAlertModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Edit Alert Threshold</h5>
        <button
          type="button"
          class="btn-close"
          data-bs-dismiss="modal"
        ></button>
      </div>
      <div class="modal-body">
        <form id="editAlertForm">
          <input type="hidden" id="editWatchId" />
          <div class="mb-3">
            <label for="editAlertPercent" class="form-label"
              >Alert Threshold (%)</label
            >
            <input
              type="number"
              class="form-control"
              id="editAlertPercent"
              step="0.1"
              min="0"
              required
            />
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
          Cancel
        </button>
        <button type="button" class="btn btn-primary" id="saveAlertBtn">
          Save Changes
        </button>
      </div>
    </div>
  </div>
</div>
{% endblock %} {% block extra_js %}
<script>
  // Check authentication
  if (!checkAuth()) {
    window.location.href = "/login";
  }

  let watchlistData = [];
  let priceChart = null;

  // Load watchlist
  async function loadWatchlist() {
    try {
      console.log("Loading watchlist...");
      const response = await apiRequest("/watchlist");

      if (!response || !response.ok) {
        console.error("Failed to load watchlist, response:", response);
        watchlistData = [];
        document.getElementById("watchlistLoading").classList.add("d-none");
        document.getElementById("watchlistEmpty").classList.remove("d-none");
        return;
      }

      const data = await response.json();
      console.log("Watchlist API response:", data);

      // Check if data is an array
      if (!Array.isArray(data)) {
        console.error("Watchlist response is not an array:", data);
        watchlistData = [];
        document.getElementById("watchlistLoading").classList.add("d-none");
        document.getElementById("watchlistEmpty").classList.remove("d-none");
        return;
      }

      // Sort by market cap descending for display and reuse
      const sortedData = [...data].sort((a, b) => {
        const aCap = parseFloat(a.market_cap) || 0;
        const bCap = parseFloat(b.market_cap) || 0;
        return bCap - aCap;
      });

      watchlistData = sortedData;

      // Hide loading and reset all states
      document.getElementById("watchlistLoading").classList.add("d-none");
      document.getElementById("watchlistEmpty").classList.add("d-none");
      document.getElementById("watchlistContent").classList.add("d-none");

      if (data.length === 0) {
        console.log("Watchlist is empty");
        document.getElementById("watchlistEmpty").classList.remove("d-none");
      } else {
        console.log(`Watchlist has ${data.length} items`);
        document.getElementById("watchlistContent").classList.remove("d-none");
        renderWatchlist(sortedData);
        populateCryptoSelector(sortedData);
      }
    } catch (error) {
      console.error("Error loading watchlist:", error);
      watchlistData = [];
      showToast("Failed to load watchlist", "danger");
      document.getElementById("watchlistLoading").classList.add("d-none");
      document.getElementById("watchlistEmpty").classList.remove("d-none");
    }
  }

  // Render watchlist table
  function renderWatchlist(data) {
    const tbody = document.getElementById("watchlistTableBody");
    tbody.innerHTML = "";

    console.log("Rendering watchlist with data:", data);

    data.forEach((item) => {
      // In new schema, crypto info is directly in the watchlist item
      const symbol = item.symbol;
      const name = item.name;
      const logoUrl = item.logo_url;
      const price = item.current_price || 0;
      const change = item.change_24h || 0;
      const marketCap = item.market_cap || 0;

      console.log(
        `${symbol}: price=${price}, change=${change}, marketCap=${marketCap}`
      );

      const changeClass = change >= 0 ? "price-positive" : "price-negative";
      const changeIcon = change >= 0 ? "▲" : "▼";

      const row = `
                <tr>
                    <td>
                        <div class="d-flex align-items-center">
                            ${
                              logoUrl
                                ? `<img src="${logoUrl}" alt="${symbol}" style="width: 32px; height: 32px; margin-right: 8px; border-radius: 50%;" onerror="this.style.display='none'">`
                                : `<div class="crypto-symbol me-3">${symbol.substring(
                                    0,
                                    3
                                  )}</div>`
                            }
                            <div>
                                  <div class="fw-bold">${symbol}</div>
                                  <small class="text-muted">${name}</small>
                            </div>
                        </div>
                    </td>
                    <td class="fw-bold">${formatPrice(price)}</td>
                    <td>
                        <span class="badge badge-change ${changeClass}">
                            ${changeIcon} ${Math.abs(change).toFixed(2)}%
                        </span>
                    </td>
                    <td>$${formatNumber(marketCap)}</td>
                    <td>
                        <span class="badge bg-info">${
                          item.alert_percent
                        }%</span>
                    </td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary" onclick="editAlert(${
                          item.watch_id
                        }, ${item.alert_percent})">
                            <i class="bi bi-bell"></i>
                        </button>
                        <button class="btn btn-sm btn-outline-danger" onclick="removeCrypto(${
                          item.watch_id
                        })">
                            <i class="bi bi-trash"></i>
                        </button>
                    </td>
                </tr>
            `;

      tbody.innerHTML += row;
    });
  }

  // Populate crypto selector
  function populateCryptoSelector(data) {
    const selector = document.getElementById("cryptoSelector");
    selector.innerHTML = '<option value="">Select a crypto...</option>';

    data.forEach((item) => {
      // Use cached info directly from watchlist
      selector.innerHTML += `<option value="${item.symbol}">${item.name} (${item.symbol})</option>`;
    });

    // Populate prediction selector
    populatePredictionSelector();
  }

  // Live search for cryptocurrencies
  let searchTimeout;
  const cryptoSearch = document.getElementById("cryptoSearch");
  const searchResults = document.getElementById("searchResults");
  const selectedCryptoDiv = document.getElementById("selectedCrypto");
  const selectedCryptoText = document.getElementById("selectedCryptoText");
  const selectedCryptoSymbol = document.getElementById("selectedCryptoSymbol");
  const selectedCryptoName = document.getElementById("selectedCryptoName");

  cryptoSearch.addEventListener("input", (e) => {
    const query = e.target.value.trim();

    clearTimeout(searchTimeout);

    if (query.length < 2) {
      searchResults.style.display = "none";
      searchResults.innerHTML = "";
      return;
    }

    searchTimeout = setTimeout(async () => {
      try {
        const response = await fetch(
          `${API_BASE}/cryptos/search?q=${encodeURIComponent(query)}`
        );
        const data = await response.json();

        if (data.length > 0) {
          searchResults.innerHTML = data
            .map(
              (crypto) => `
            <button type="button" class="list-group-item list-group-item-action search-result-item" 
                    data-id="${crypto.id || ""}" 
                    data-symbol="${crypto.symbol}" 
                    data-name="${crypto.name}">
              <div class="d-flex justify-content-between align-items-center">
                <div>
                  <strong>${crypto.symbol}</strong> - ${crypto.name}
                </div>
              </div>
            </button>
          `
            )
            .join("");
          searchResults.style.display = "block";

          // Add click handlers to search results
          document.querySelectorAll(".search-result-item").forEach((item) => {
            item.addEventListener("click", () => {
              const cryptoId = item.dataset.id;
              const symbol = item.dataset.symbol;
              const name = item.dataset.name;

              document.getElementById("selectedCryptoId").value = cryptoId;
              selectedCryptoSymbol.value = symbol;
              selectedCryptoName.value = name;
              selectedCryptoText.textContent = `${name} (${symbol})`;
              selectedCryptoDiv.style.display = "block";

              cryptoSearch.value = "";
              searchResults.style.display = "none";
              searchResults.innerHTML = "";
            });
          });
        } else {
          searchResults.innerHTML =
            '<div class="list-group-item text-muted">No results found</div>';
          searchResults.style.display = "block";
        }
      } catch (error) {
        console.error("Search error:", error);
      }
    }, 300);
  });

  // Hide search results when clicking outside
  document.addEventListener("click", (e) => {
    if (!cryptoSearch.contains(e.target) && !searchResults.contains(e.target)) {
      searchResults.style.display = "none";
    }
  });

  // Add crypto to watchlist
  document
    .getElementById("addCryptoBtn")
    .addEventListener("click", async () => {
      const symbol = selectedCryptoSymbol.value.trim().toUpperCase();
      const cryptoName = selectedCryptoName.value;
      const cryptoId = document.getElementById("selectedCryptoId").value;
      const alertPercent = parseFloat(
        document.getElementById("alertPercent").value
      );

      if (!symbol) {
        showToast("Please search and select a cryptocurrency", "warning");
        return;
      }

      try {
        const requestBody = {
          symbol,
          alert_percent: alertPercent,
        };

        // Include api_crypto_id if available
        if (cryptoId) {
          requestBody.api_crypto_id = parseInt(cryptoId);
        }

        const response = await apiRequest("/watchlist/add", {
          method: "POST",
          body: JSON.stringify(requestBody),
        });

        if (response.ok) {
          const displayName = cryptoName || symbol;
          showToast(`${displayName} added to watchlist!`, "success");
          bootstrap.Modal.getInstance(
            document.getElementById("addCryptoModal")
          ).hide();
          document.getElementById("addCryptoForm").reset();
          selectedCryptoDiv.style.display = "none";
          selectedCryptoSymbol.value = "";
          selectedCryptoName.value = "";
          document.getElementById("selectedCryptoId").value = "";

          // Reload watchlist and update selectors
          await loadWatchlist();
          populatePredictionSelector();
        } else {
          const data = await response.json();
          showToast(data.error || "Failed to add crypto", "danger");
        }
      } catch (error) {
        console.error("Error adding crypto:", error);
        showToast("An error occurred", "danger");
      }
    });

  // Edit alert
  function editAlert(watchId, currentPercent) {
    document.getElementById("editWatchId").value = watchId;
    document.getElementById("editAlertPercent").value = currentPercent;
    new bootstrap.Modal(document.getElementById("editAlertModal")).show();
  }

  // Save alert
  document
    .getElementById("saveAlertBtn")
    .addEventListener("click", async () => {
      const watchId = parseInt(document.getElementById("editWatchId").value);
      const alertPercent = parseFloat(
        document.getElementById("editAlertPercent").value
      );

      try {
        const response = await apiRequest("/alerts/update", {
          method: "POST",
          body: JSON.stringify({
            watch_id: watchId,
            alert_percent: alertPercent,
          }),
        });

        if (response.ok) {
          showToast("Alert updated!", "success");
          bootstrap.Modal.getInstance(
            document.getElementById("editAlertModal")
          ).hide();
          loadWatchlist();
        } else {
          showToast("Failed to update alert", "danger");
        }
      } catch (error) {
        console.error("Error updating alert:", error);
        showToast("An error occurred", "danger");
      }
    });

  // Remove crypto
  async function removeCrypto(watchId) {
    if (!confirm("Remove this cryptocurrency from your watchlist?")) {
      return;
    }

    try {
      const response = await apiRequest(`/watchlist/${watchId}`, {
        method: "DELETE",
      });

      if (response.ok) {
        showToast("Removed from watchlist", "success");
        await loadWatchlist();
        await loadPopularCryptos(); // Refresh popular cryptos to update button states
      } else {
        showToast("Failed to remove", "danger");
      }
    } catch (error) {
      console.error("Error removing crypto:", error);
      showToast("An error occurred", "danger");
    }
  }

  let currentSymbol = null;
  let currentDays = 1; // Default to 24h

  // Load price history from CoinGecko API
  async function loadPriceHistory(symbol, days) {
    if (!symbol) return;

    document.getElementById("chartEmpty").classList.add("d-none");
    document.getElementById("chartContent").classList.add("d-none");
    document.getElementById("chartLoading").classList.remove("d-none");

    try {
      const response = await fetch(
        `${API_BASE}/cryptos/${symbol}/history?days=${days}`
      );
      const data = await response.json();

      document.getElementById("chartLoading").classList.add("d-none");
      document.getElementById("chartContent").classList.remove("d-none");

      renderPriceChart(data);
    } catch (error) {
      console.error("Error loading price history:", error);
      showToast("Failed to load price history", "danger");
      document.getElementById("chartLoading").classList.add("d-none");
    }
  }

  // Handle crypto selector change
  document
    .getElementById("cryptoSelector")
    .addEventListener("change", async (e) => {
      currentSymbol = e.target.value;

      if (!currentSymbol) {
        document.getElementById("chartContent").classList.add("d-none");
        document.getElementById("chartEmpty").classList.remove("d-none");
        return;
      }

      loadPriceHistory(currentSymbol, currentDays);
    });

  // Handle time period button clicks
  document
    .getElementById("timePeriodButtons")
    .addEventListener("click", (e) => {
      const btn = e.target.closest("button");
      if (!btn || !currentSymbol) return;

      // Update active button
      document
        .querySelectorAll("#timePeriodButtons button")
        .forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");

      // Get days value
      const days = btn.dataset.days;
      currentDays = parseInt(days);

      // Reload chart
      loadPriceHistory(currentSymbol, currentDays);
    });

  // Render price chart
  function renderPriceChart(data) {
    const ctx = document.getElementById("priceChart");

    if (priceChart) {
      priceChart.destroy();
    }

    const historyDates = data.prices.map((p) =>
      new Date(p[0]).toLocaleDateString()
    );
    const historyPrices = data.prices.map((p) => p[1]);

    // Calculate and display stats from API data if available
    if (data.ohlc && data.ohlc.length > 0) {
      const allData = data.ohlc;
      const open = allData[0].open;
      const close = allData[allData.length - 1].close;
      const high = Math.max(...allData.map((d) => d.high));
      const low = Math.min(...allData.map((d) => d.low));
      const totalVolume = allData.reduce((sum, d) => sum + d.volume, 0);

      document.getElementById("statOpen").textContent = "$" + open.toFixed(2);
      document.getElementById("statHigh").textContent = "$" + high.toFixed(2);
      document.getElementById("statLow").textContent = "$" + low.toFixed(2);
      document.getElementById("statVolume").textContent =
        formatNumber(totalVolume);
    }

    const datasets = [
      {
        label: "Price (USD)",
        data: historyPrices,
        borderColor: "#3b82f6",
        backgroundColor: "rgba(59, 130, 246, 0.1)",
        fill: true,
        tension: 0.4,
        pointRadius: 0,
        pointHoverRadius: 4,
      },
    ];

    priceChart = new Chart(ctx, {
      type: "line",
      data: {
        labels: historyDates,
        datasets: datasets,
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: true,
            position: "top",
          },
          tooltip: {
            mode: "index",
            intersect: false,
            callbacks: {
              label: function (context) {
                let label = context.dataset.label || "";
                if (label) {
                  label += ": ";
                }
                if (context.parsed.y !== null) {
                  label += "$" + context.parsed.y.toFixed(2);
                }
                return label;
              },
            },
          },
        },
        scales: {
          y: {
            beginAtZero: false,
            ticks: {
              callback: function (value) {
                return "$" + value.toFixed(2);
              },
            },
          },
        },
      },
    });
  }

  // Refresh button
  document.getElementById("refreshBtn").addEventListener("click", (e) => {
    e.preventDefault();
    loadWatchlist();
    showToast("Refreshed!", "info");
  });

  // Download CSV
  document.getElementById("downloadCsvBtn").addEventListener("click", (e) => {
    e.preventDefault();
    const symbol = document.getElementById("cryptoSelector").value;

    if (!symbol) {
      showToast("Please select a cryptocurrency first", "warning");
      return;
    }

    const token = getAuthToken();
    window.location.href = `/api/export/history/${symbol}?days=30&token=${token}`;
  });

  // Download watchlist CSV
  document
    .getElementById("downloadWatchlistBtn")
    .addEventListener("click", (e) => {
      e.preventDefault();
      const token = getAuthToken();
      window.location.href = `/api/export/watchlist?token=${token}`;
    });

  // Prediction chart variable
  let predictionChart = null;
  let currentPredictionSymbol = null;
  let currentPredictionDays = 1; // Default to 24h

  // Populate prediction crypto selector from watchlist
  function populatePredictionSelector() {
    const selector = document.getElementById("predictionCryptoSelector");
    const watchlistSelector = document.getElementById("cryptoSelector");
    selector.innerHTML = watchlistSelector.innerHTML;
  }

  // Load price predictions with ML model
  async function loadPredictionHistory(symbol, days) {
    if (!symbol) return;

    document.getElementById("predictionEmpty").classList.add("d-none");
    document.getElementById("predictionContent").classList.add("d-none");
    document.getElementById("predictionLoading").classList.remove("d-none");

    try {
      // Get selected model type
      const modelType = document.getElementById(
        "predictionModelSelector"
      ).value;

      const response = await apiRequest(
        `/history/${symbol}?days=${days}&predict=true&model_type=${modelType}`
      );
      const data = await response.json();

      document.getElementById("predictionLoading").classList.add("d-none");
      document.getElementById("predictionContent").classList.remove("d-none");

      renderPredictionChart(data);
    } catch (error) {
      console.error("Error loading predictions:", error);
      showToast("Failed to load predictions", "danger");
      document.getElementById("predictionLoading").classList.add("d-none");
    }
  }

  // Handle prediction crypto selector change
  document
    .getElementById("predictionCryptoSelector")
    .addEventListener("change", async (e) => {
      currentPredictionSymbol = e.target.value;

      if (!currentPredictionSymbol) {
        document.getElementById("predictionContent").classList.add("d-none");
        document.getElementById("predictionEmpty").classList.remove("d-none");
        return;
      }

      loadPredictionHistory(currentPredictionSymbol, currentPredictionDays);
    });

  // Handle prediction model change
  document
    .getElementById("predictionModelSelector")
    .addEventListener("change", () => {
      if (currentPredictionSymbol) {
        loadPredictionHistory(currentPredictionSymbol, currentPredictionDays);
      }
    });

  // Handle prediction time period button clicks
  document
    .getElementById("predictionTimePeriodButtons")
    .addEventListener("click", (e) => {
      const btn = e.target.closest("button");
      if (!btn || !currentPredictionSymbol) return;

      // Update active button
      document
        .querySelectorAll("#predictionTimePeriodButtons button")
        .forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");

      // Get days value - this represents how far into the FUTURE to predict
      const days = btn.dataset.days;
      currentPredictionDays = days === "max" ? 365 : parseInt(days);

      // Reload chart
      loadPredictionHistory(currentPredictionSymbol, currentPredictionDays);
    });

  // Render prediction chart with only future predicted data
  function renderPredictionChart(data) {
    const ctx = document.getElementById("predictionChart");

    if (predictionChart) {
      predictionChart.destroy();
    }

    // Only show prediction data (future prices)
    const predictionDates = data.predictions
      ? data.predictions.map((p) => new Date(p.date).toLocaleDateString())
      : [];
    const predictionPrices = data.predictions
      ? data.predictions.map((p) => p.predicted_price)
      : [];

    // Calculate and display stats from predicted prices
    if (predictionPrices.length > 0) {
      const open = predictionPrices[0];
      const close = predictionPrices[predictionPrices.length - 1];
      const high = Math.max(...predictionPrices);
      const low = Math.min(...predictionPrices);

      document.getElementById("predictionStatOpen").textContent =
        "$" + open.toFixed(2);
      document.getElementById("predictionStatHigh").textContent =
        "$" + high.toFixed(2);
      document.getElementById("predictionStatLow").textContent =
        "$" + low.toFixed(2);
      document.getElementById("predictionStatVolume").textContent = "N/A";
    }

    const datasets = [
      {
        label: "Predicted Price",
        data: predictionPrices,
        borderColor: "#10b981",
        backgroundColor: "rgba(16, 185, 129, 0.1)",
        fill: true,
        tension: 0.4,
        pointRadius: 2,
        pointHoverRadius: 5,
      },
    ];

    predictionChart = new Chart(ctx, {
      type: "line",
      data: {
        labels: predictionDates,
        datasets: datasets,
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: true,
            position: "top",
          },
          tooltip: {
            mode: "index",
            intersect: false,
            callbacks: {
              label: function (context) {
                let label = context.dataset.label || "";
                if (label) {
                  label += ": ";
                }
                if (context.parsed.y !== null) {
                  label += "$" + context.parsed.y.toFixed(2);
                }
                return label;
              },
            },
          },
        },
        scales: {
          y: {
            beginAtZero: false,
            ticks: {
              callback: function (value) {
                return "$" + value.toFixed(2);
              },
            },
          },
        },
      },
    });
  }

  // Load popular cryptocurrencies
  async function loadPopularCryptos() {
    try {
      const popularTableBody = document.getElementById(
        "popularCryptosTableBody"
      );
      popularTableBody.innerHTML = "";

      // Fetch watched crypto IDs first
      let watchedIds = [];
      try {
        const watchedResponse = await apiRequest("/watchlist/ids");
        if (watchedResponse.ok) {
          const watchedData = await watchedResponse.json();
          watchedIds = watchedData.watched_ids || [];
          console.log("User is watching crypto IDs:", watchedIds);
        }
      } catch (err) {
        console.error("Error fetching watched IDs:", err);
      }

      // Fetch top cryptocurrencies from the toplist endpoint
      const response = await fetch(`${API_BASE}/cryptos/top?limit=10`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
        },
      });

      if (!response.ok) {
        throw new Error("Failed to fetch top cryptocurrencies");
      }

      const result = await response.json();
      const topCryptos = result.data || [];

      if (topCryptos.length === 0) {
        throw new Error("No cryptocurrencies data available");
      }

      const rows = [];

      // Check which cryptos are in watchlist by ID
      console.log("Current watchlistData:", watchlistData);
      const watchlistIds = new Set(watchedIds);
      console.log("Watchlist IDs Set:", Array.from(watchlistIds));

      // Create rows for each crypto
      for (const data of topCryptos) {
        if (!data) continue;

        const isInWatchlist = watchlistIds.has(data.id);
        console.log(
          `Crypto ${data.symbol} (ID: ${data.id}) - In watchlist: ${isInWatchlist}`
        );

        const changeClass =
          data.change_24h >= 0 ? "text-success" : "text-danger";
        const changeIcon =
          data.change_24h >= 0 ? "bi-arrow-up" : "bi-arrow-down";
        const marketCapDisplay = formatNumber(data.market_cap);
        const volumeDisplay = formatNumber(data.volume_24h);

        // Button styling based on watchlist status
        const buttonClass = isInWatchlist
          ? "btn-success"
          : "btn-outline-primary";
        const buttonIcon = isInWatchlist ? "bi-check-circle" : "bi-plus-circle";
        const buttonDisabled = isInWatchlist ? "disabled" : "";
        const buttonTitle = isInWatchlist
          ? "Already in watchlist"
          : "Add to watchlist";

        const row = `
          <tr>
            <td>
              <div class="d-flex align-items-center">
                ${
                  data.logo_url
                    ? `<img src="${data.logo_url}" alt="${data.symbol}" style="width: 32px; height: 32px; margin-right: 8px; border-radius: 50%;" onerror="this.style.display='none'">`
                    : ""
                }
                <div>
                  <strong>${data.symbol}</strong>
                  <div class="small text-muted">${data.name}</div>
                </div>
              </div>
            </td>
            <td>$${data.price.toLocaleString("en-US", {
              minimumFractionDigits: 2,
              maximumFractionDigits: 2,
            })}</td>
            <td class="${changeClass}">
              <i class="bi ${changeIcon}"></i>
              ${Math.abs(data.change_24h).toFixed(2)}%
            </td>
            <td>$${marketCapDisplay}</td>
            <td>$${volumeDisplay}</td>
            <td>
              <button class="btn btn-sm ${buttonClass} add-to-watchlist-btn" 
                      data-id="${data.id}"
                      data-symbol="${data.symbol}"
                      data-name="${data.name}"
                      data-price="${data.price}"
                      data-market-cap="${data.market_cap}"
                      data-volume="${data.volume_24h}"
                      data-change="${data.change_24h}"
                      title="${buttonTitle}"
                      ${buttonDisabled}>
                <i class="bi ${buttonIcon}"></i>
              </button>
            </td>
          </tr>
        `;
        rows.push(row);
      }

      // Add all rows at once
      popularTableBody.innerHTML = rows.join("");

      document.getElementById("popularCryptosLoading").classList.add("d-none");
      document
        .getElementById("popularCryptosContent")
        .classList.remove("d-none");
    } catch (error) {
      console.error("Error loading popular cryptos:", error);
      document.getElementById("popularCryptosLoading").innerHTML =
        '<p class="text-danger">Failed to load popular cryptocurrencies</p>';
    }
  }

  // Set up event delegation for add to watchlist buttons (runs once)
  document
    .getElementById("popularCryptosTableBody")
    .addEventListener("click", async (e) => {
      const btn = e.target.closest(".add-to-watchlist-btn");
      if (!btn || btn.disabled) return;

      const symbol = btn.dataset.symbol;
      const name = btn.dataset.name;
      const originalHTML = btn.innerHTML;

      // Show loading spinner
      btn.disabled = true;
      btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';

      try {
        const apiCryptoId = parseInt(btn.dataset.id);
        console.log(`Adding ${symbol} (ID: ${apiCryptoId}) to watchlist`);

        const response = await apiRequest("/watchlist/add", {
          method: "POST",
          body: JSON.stringify({
            symbol,
            api_crypto_id: apiCryptoId,
            alert_percent: 5.0,
          }),
        });

        console.log("Add to watchlist response:", response);

        if (response.ok) {
          const result = await response.json();
          console.log("Successfully added to watchlist:", result);
          showToast(`${name} added to watchlist!`, "success");

          // Reload both watchlist and popular cryptos to update UI
          console.log("Reloading watchlist and popular cryptos...");
          await loadWatchlist();
          await loadPopularCryptos();
          console.log("Reload complete");
        } else {
          let errorMessage = "Failed to add crypto";
          try {
            const data = await response.json();
            errorMessage = data.error || errorMessage;
          } catch (e) {
            console.error("Failed to parse error response:", e);
          }
          showToast(errorMessage, "danger");
          btn.innerHTML = originalHTML;
          btn.disabled = false;
        }
      } catch (error) {
        console.error("Error adding crypto:", error);
        showToast("An error occurred", "danger");
        btn.innerHTML = originalHTML;
        btn.disabled = false;
      }
    });

  // Load watchlist on page load
  loadWatchlist();
  loadPopularCryptos();

  // Auto-refresh prices every 2 minutes (cache refreshes every 5 minutes)
  setInterval(() => {
    console.log("Auto-refreshing prices...");
    loadWatchlist();
    loadPopularCryptos();
  }, 120000); // 2 minutes = 120000ms
</script>
{% endblock %}
